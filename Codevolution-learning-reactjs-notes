=> requirements node js, editor(visual studio)

=> create react project
	a. # npx create-react-app <project name>
	b. # npm install create-react-app -g
	c. # create-react-app <project-name>

What is npx -> npm package runner.

=> to run react project
	# npm start

=> index.html file is the only file your going to have in your react js project. In this file we have a div with id 'root' for rendering complete project.
=> if you run 'npm start' command in terminal index.html page will serve you.

Components
==========
=> Components descrive a part of the user interface.
=> They are reusable and can be nested inside other components.

Types:
  1. Stateless Functional Components
      a. Javascript Functions
          Ex: function Welcome(props){ return <h1>Hello, {props.name}</h1>; }
  2. Stateful Components
      a. Class extending component class
      b. Render method returning HTML
          Ex: class Welcome extends React.Component{ render(){ return <h1>Hello, {this.props.name}</h1>; } }

Functional Components
======================
Example
-------
normal
  import React from 'react'
  function Greet() { return ( <div> fgsdfgsdfgsdfg </div> ) }
  export default Greet

with arrow function 
  const Greet = () => <h1>asdfasfasdf</h1> export default Greet

Class components
================
import React, {Component} from 'react'
class Welcome extends Component{
  render(){ return <h1> Class component </h1> }  
}
export default Welcome

Function components vs Class components
=======================================
Fucntional
----------
1. Simple functions
2. Use Func components as much as possible
3. Absence of 'this' keyword
4. Solution without using state
5. Mainly responsible for the UI
6. Stateless/ Dumb / Presentational

Class
-----
1. More feature rich
2. Maintain their own private data - state
3. Complex UI logic
4. Provide lifecycle hooks
5. Stateful / Smart / Container

Hooks
=====
=> No breaking changes
=> Completely opt-in & 100% backwards-compatible.
=> What ever we've learned so far in this series still holds good
=> Components types - Functional components and Class components
=> Using state, lifecycle methods and 'this' bonding
=> After understanding state, event binding and lifecycle hooks in class components

JSX
===
1. Javascript XML(JSX) - Extension to the JavaScript language syntax.
2. Write XML - like code for elements and components
3. JSX tags have a tag name, attributes and children
4. JSX is not a necessity to write React applications
5. JSX makes your react code simpler and elegant
6. JSX ultimately transpiles to pure JavaScript which is understood by the browsers

react component with jsx
------------------------
Greet.js
--------
import React from 'react'
const Greet = () => {
    return React.createElement(
        'div',
        {id: 'hello', className: 'dummyClass'},
        React.createElement('h1', null, 'Hello Vishwas')
    )
}

export default Greet

JSX differences
---------------
class - className
for - htmlFor
camelCase property naming convension
  onclick - onClick
  tabindex - tabIndex

PRoPERTIES (Props)
==================
=> Props are immutable (value cannot be changed once assigned).
Example: 
import './App.css';
import Greet from './components/Greet';
function App() {
  return (
    <div className="App">
       <Greet name="madhu" project="iti"/>
       <Greet name="praneeth" project="dca"/>
       <Greet name="srinivas" project="apbocwwb"/>
       
    </div>
  );
}
import React from 'react'
const Greet = props => {
    return <h1> Hello {props.name}, working on project {props.project}</h1>
}
export default Greet

STATE
=====
props vs state
--------------
Props
  a. props get passed to the component
  b. Function parameters
  c. props are immutable
  d. props - Functional Components, this.props - Class Components
State
  a. state is managed within the component
  b. Variables declared in the function body
  c. state can be changed
  d. useState Hook - Functional Components, this.state - Class Components

Example:
import React, { Component } from "react";
class Message extends Component{
constructor(){
    super()
    this.state = {
        message: 'Welcome Visitor'
    }
}
changeMessage(){
    this.setState({
        message: 'Thanks for subscribe'
    })
}
    render(){
        return (
            <div>
            <h1>{this.state.message}</h1>
            <button onClick={()=>this.changeMessage()}>Subscribe</button>
            </div>
        )
    }
}
export default Message

setState
********
1. Always make use of setState and never modify the state directly
2. Code has to be executed after the state has been updated? 
    Place that code in the call back function which is the second argument to the setState method
3. When you have to update state based on the previous state value, pass in a function as an argument
    instead of the regular object.

import React, { Component } from 'react'

export class Counter extends Component {

    constructor(props) {
      super(props)
    
      this.state = {
         count: 0
      }
    }
    
    increment(){
        //this.setState({
       //     count: this.state.count + 1
       // },()=> console.log('last value is', this.state.count))
       this.setState(prevState => ({
        count: prevState.count + 1
       }))
    }
    incrementFive(){
        this.increment()
        this.increment()
        this.increment()
        this.increment() 
    }

  render() {
    return (
      <div>
        count - {this.state.count}
        <button onClick={()=> this.incrementFive()}>Increment</button>
      </div>
    )
  }
}

export default Counter

destructuring props and state
*****************************
import React from 'react'
//const Greet = ({name,project}) => {
    const Greet = props =>{
       const{name, project} = props
    return <h1> Hello {name}, working on project {project}</h1>
}
export default Greet

EVENT HANDLING
==============
onClick
-------
functional component
--------------------
import React from 'react'
function ClickFunction() {
    function clickhander(){
        alert("clicked");
    }
  return (<div><button onClick={clickhander}>Click</button></div>)}
export default ClickFunction

class component
----------------
import React, { Component } from 'react'
class ClassClick extends Component {
    classclickhandler(){
        alert('clicked');
    }
  render() {
    return (
      <div>
        <button onClick={this.classclickhandler}>Click</button>
      </div>
    )
  }
}
export default ClassClick

BINDING EVENT HANDLERS
======================

import React, { Component, useState } from 'react'
class EventBind extends Component {
constructor(props) {
  super(props)
  this.state = {
     message: 'Hello user'
  }
  //this.eventhandler = this.eventhandler.bind(this)
}
//eventhandler(){
  //  this.setState({
    //    message: 'good bye user'  
    //})
    //console.log('dfasdf');
//}
eventhandler = () =>{
    this.setState({
        message: 'Good bye!'
    })
}
  render() {
    return (
      <div>
        <div>{this.state.message}</div>
        {/*<button onClick={this.eventhandler.bind(this)}>Click</button>*/}
        {/*<button onClick={()=> this.eventhandler()}>Click</button>*/}
        <button onClick={this.eventhandler}>Click</button>
      </div>
    )
  }
}
export default EventBind

METHOD AS PROPS
===============
import React, { Component } from 'react'
import ChildComponent from './ChildComponent'
class ParentComponent extends Component {
    constructor(props) {
      super(props)
      this.state = {
         parentName: 'Parent'
      }
      this.greetParent = this.greetParent.bind(this)
    }
    //greetParent(){
       // alert(`Hello ${this.state.parentName}`)
    //}
    greetParent(childName){
        alert(`Hello ${this.state.parentName} from ${childName}`)
    }
  render() {
    return (
      <div>
        <ChildComponent greetHandler={this.greetParent}/>
      </div>
    )
  }
}
export default ParentComponent

import React from 'react'
function ChildComponent(props) {
  return (
    <div>
     {/* <div><button onClick={props.greetHandler}>Greet Parent</button></div> */}
     <div><button onClick={()=>props.greetHandler('Child')}>Greet Parent</button></div>
    </div>
  )
}
export default ChildComponent

CONDITIONAL RENDERING
=====================

import React, { Component } from 'react'

class UserGreeting extends Component {
    constructor(props) {
      super(props)
    
      this.state = {
         isLoggedIn: false
      }
    }
    
  render() {
    
    //first way
    //using if else condition
    //if(this.state.isLoggedIn){
       // return <div>Welcome madhu</div>
    //}else{
        //return <div>Welcome Guest</div>
    //}

    //second way
    //using variable
    //let message
    //if(this.state.isLoggedIn){
      //  message = <div>Welcome madhu</div>
    //}else{
      //  message = <div>Welcome Guest</div>
    //}
    //return <div>{message}</div>

    //third way
    //mostly used
    //ternary operator
    //return this.state.isLoggedIn?(<div>Welcome madhu</div>):(<div>Welcome Guest</div>)

    //fourth way
    //only true condition rendering
    //short circuit operator
    return this.state.isLoggedIn && <div>Welcome madhu</div>

  }
}

export default UserGreeting

LIST RENDERING
==============
within single component
-----------------------
import React from 'react'

function NamesList() {
//first & second & third
//const name = ['madhu','praneeth','srinivas']
const persons = [
    {name: 'madhu', age: '29', lang: 'Java'},
    {name: 'praneeth', age: '30', lang: 'SB'},
    {name: 'srinivas', age: '27', lang: 'React'},
]

//third way
//const namesList = names.map(name => <h2>{name}</h2>)

//fourth way
const personsList = persons.map(person => 
    <div><h2>Iam {person.name}, my age is  {person.age} , I know  {person.lang}</h2> </div>
)

  return (
    <div>
    {/** Normal Rendering
      <h4>{names[0]}</h4>
      <h5>{names[1]}</h5>
      <h6>{names[2]}</h6>
       */}

       {/**second way
     {
        names.map(name => <h2>{name}</h2>)
       }
    */}
      
    {/*third way*/}
    {/*{namesList}*/}

{/*fourth way*/}
{ personsList }


    </div>
  )
}

export default NamesList

within morethan a component
---------------------------
import React from 'react'
function Person({ person }) {
    return (
        <div>
            <h2>Iam {person.name}, my age is  {person.age} , I know  {person.lang}</h2>
        </div>
    )
}
export default Person

import React from 'react'
import Person from './Person'
function NamesList() {
    const persons = [
        { name: 'madhu', age: '29', lang: 'Java' },
        { name: 'praneeth', age: '30', lang: 'SB' },
        { name: 'srinivas', age: '27', lang: 'React' },
    ]
    const personsList = persons.map(person =>
        <Person person={person} />
    )
    return (
        <div>{personsList}</div>
    )
}
export default NamesList

LIST AND KEYS
=============
=> A 'key' is a special string attribute you need to include when creating lists of elements.
=> Keys give the elements a stable identity.
=> Keys help React identify which items have changed, are added, or are removed.
=> Help in efficient update of the user interface.

if your list have unique values
-------------------------------
 const personsList = persons.map(person =>
        <Person key={person.name} person={person} />
    )

if your list have not any key values
-------------------------------------
 const personsList = persons.map((person, index) =>
        <Person key={index} person={person} />
    )

When to use index as key?
-------------------------
1. The items in your list do not have a unique id.
2. The list is a static list and will not change.
3. The list will never be ordered or filtered.


STYLING AND CSS
===============
1. CSS Stylesheets
2. Inline styling
3. CSS Module
4. CSS in JS Libraries

1. CSS Stylesheets
-------------------
/*first and second*/
.primary{
    color: orange;
}
.font-xl{
    font-size: 72px;
}

import React from 'react'
import './myStyle.css'
function Stylesheet(props) {
    let className = props.primary ? 'primary' : ''
    return (
        <div>
            {/**first way */}
            {/**<h1 className='primary'>My Style in react</h1> */}

            {/**second way */}
            <h1 className={`${className} font-xl`}>My Style in react</h1>
        </div>
    )
}
export default Stylesheet

import './App.css';
import Stylesheet from './components/Stylesheet';
function App() {
  return (
    <div className="App">
      {/**first way */}
      {/**<Stylesheet/> */}

      {/**second way */}
      {/**true means styles applies other wise not */}
      <Stylesheet primary={true} />

    </div>
  );
}
export default App;


2. Inline styling
-----------------
import './App.css'; 
import Inline from './components/Inline';
function App() {
  return (
    <div className="App">
      <Inline/>
    </div>
  );
}
export default App;

BASICS OF FORM HANDLING
=======================
import React, { Component } from "react";

class Form extends Component {

  constructor(props) {
    super(props);

    this.state = {
      username: "",
      comments: ""
    };
  }

  handleUsernameChange = event =>{
    this.setState({
      username: event.target.value
    })
  }

  handleCommentsChange = event =>{
    this.setState({
      comments: event.target.value
    })
  }

  handleTopicChange = event =>{
    this.setState({
      topic: event.target.value
    })
  }

  handleSubmit = event =>{
    alert(`${this.state.username} ${this.state.comments} ${this.state.topic}`)
    event.preventDefault()
  }

  render() {
    const{username, topic, comments} = this.state
    return (
      
        <form onSubmit={this.handleSubmit}>
          <div>
          <label>Username</label>
          <input
            type="text"
            value={username}
            onChange={this.handleUsernameChange}
          />
          </div>
          <div>
          <label>Comments</label>
          <textarea value={comments} onChange={this.handleCommentsChange}></textarea>
          </div>
          <div>
            <label>Topic</label>
            <select value={topic} onChange={this.handleTopicChange}>
              <option value="react">React</option>
              <option value="vue">Vue</option>
              <option value="angular">Angular</option>
            </select>
          </div>
          <button type="submit">Submit</button>
        </form>
      
    );
  }
}

export default Form;


COMPONENT LIFE CYCLE METHODS
============================
1. Mounting
	When an instance of a component is being created and inserted into the DOM
	constructor, static getDerivedStateFromProps, render and componentDidMount
2. Updating
	When a component is being re-rendered as a result of changes to either its props or state
	static getDerivedStateFromProps, shouldComponentUpdate, render, getSnapshotBeforeUpdate and componentDidUpdate
3. Unmounting
	When a component is being removed from the DOM
	componentWillUnmount
4. Error Handling
	When there is an error during rendering, in a life cycle method, or in the constructor of any child component
	static getDerivedStateFromError and componentDidCatch

MOUNTING LIFE CYCLE METHODS
===========================
1. constructor(props) 
	A special function that will get called whenever a new component created
	Intializing state Binding the event handlers
	Do not cause side effects. Ex: HTTP requests
	super(props) Directly overwrite this.state

2. static getDerivedStateFromProps(prop, state)
	When the state of the component depends on changes in props over time
	set the state
	Do not cause side effects. Ex: HTTP requests

3. render()
	Only required method
	Read Props & State and return JSX
	Do not change state or interact with DOM or make ajax calls
	Children components lifecycle methods are also executed

4. componentDidMount()
	Invoked immediately after a component and all its children components have been rendered to the DOM
	Cause side effects. Ex: Interact with the DOM or perform any ajax calls to load data

UPDATING LIFE CYCLE METHODS
===========================
1. static getDerivedStateFromProps(props,state)
	Method is called every time a component is re-rendered
	Set the state
	Do not cause side effects. Ex: HTTPS requests

2. shouldComponentUpdate(nextProps, nextState)
	Dictates if the component should re-render or not
	Performance optimization
	Do not cause side effects. Ex: HTTP requests calling the setState method

3. render()
	Only required method
	Read Props & State and return JSX
	Children components lifecycle methods are also executed

4. getSnapshotBeforeUpdate(prevProps, prevState)
	Called right before the changes from the virtual DOM are to be reflected in the DOM
	Capture some information from the DOM
	Method will either return null or return a value. Returned value will be passed as the third parameter to the next method

5. componentDidUpdate(prevProps, prevState, snapshot)
	Called after the render is finished in the re-render cycles
	Cause side effects

UNMOUNTING PHASE METHOD
=======================
1. componentWillUnmount()
	Method is invoked immediately before a component is unmounted and destroyed
	Cancelling any network requests, removing event handlers, cancelling any subscriptions and invalidating timers.
	Do not call the setState method

ERROR HANDLING PHASE METHODS
===========================
static getDerivedStateFromError(error) and componentDidCatch(error, info)
	When there is an error either during rendering, in a lifecycle method, or in the constructor of any child component	

code snippets
-------------
import React, { Component } from 'react'
import LifeCycleB from './LifeCycleB'

class LifeCycleA extends Component {

constructor(props) {
  super(props)

  this.state = {
     name: 'madhu'
  }
  console.log('LifeCycleA Constructor')
}
static getDerivedStateFromProps(props, state){
    console.log('LifeCycleA getDerivedStateFromProps')
    return null
}
componentDidMount(){
    console.log('LifeCycleA componentDidMount')
}
shouldComponentUpdate(){
    console.log('LifeCycleA shouldComponentUpdate')
    return true
}
getSnapshotBeforeUpdate(prevProps, prevState){
    console.log('LifeCycleA getSnapshotBeforeUpdate') 
    return null
}
componentDidUpdate(){
    console.log('LifeCycleA componentDidUpdate') 
}
changeState = () =>{
    this.setState({
        name: 'madhu'
    })
}
  render() {
    console.log('LifeCycleA render')
    return (
      <div>
        <LifeCycleB/>
        LifeCycleA
        <button onClick={this.changeState}>Change State</button>
        </div>
    )
  }
}

export default LifeCycleA


FRAGMENTS
=========
import React from 'react'
import Column from './Column'
function Table() {
  return (
    <div>
        <table>
            <tbody>
                <tr>
                    <Column/>
                </tr>
            </tbody>
        </table>
    </div>
  )
}
export default Table

import React from 'react'
function Column() {
  return (
    <React.Fragment> 
        <td>SNO</td>
        <td>NAME</td>
    </React.Fragment>
  )
}
export default Column

PURE COMPONENTS
===============
Pure component
	=> A Pure component implements shouldComponentUpdate with a shallow prop and state comparison.
	=> SC of prevState with currentState & SC of prevProps with currentProps difference Re-render component.
Regular component
	=> A regular component does not implement the shouldComponentUpdate method. It always returns true by default.
Pure component
	=> A pure component on the other hand implements shouldComponentUpdate with a shallow props and state comparison

Shallow Comparison (SC)
-----------------------
Primitive types:
	a (SC) b return true. if a and b have the same value and are of the same type.
	Example: String 'madhu' (SC) String 'madhu' returns true
Complex Type:
	a (SC) b returns true. if a and b reference the exact same object.
	Example 1:
	var a = [1,2,3];
	var b = [1,2,3];
	var c = a;
	var ab_eq = (a == b); //false
	var ac_eq = (a == c); //true

	Example 2:
	var a = { x: 1, y: 2};
	var b = { x: 1, y: 2};
	var c = a;
	var ab_eq = (a == b); //false
	var ac_eq = (a == c); //true

SUMMARY
-------
=> We can create a component by extending the PureComponent class.
=> A Pure component implements the shouldComponentUpdate lifecycle method by performing a shallow comparison on the props and state of the component.
=> If there is no difference, the component is not re-rendered (performance boost)
=> It's a good idea to ensure that all the children components are also pure to avoid unexpected behaviour.
=> Never mutate the state. Always return a new object that reflects the new state.

MEMO
====
import React from 'react'

function MemoComp({name}) {
    console.log('memo component')
  return (
    <div>
      {name}
    </div>
  )
}

export default React.memo(MemoComp)

REFs
====
import React, { Component } from 'react'

class RefsDemo extends Component {
    constructor(props) {
        super(props)
        this.inputRef = React.createRef()
      }
  
      componentDidMount(){
        this.inputRef.current.focus()
          console.log('RefsDemo componentDidMount')
      }

      clickHandler = () =>{
        alert(this.inputRef.current.value)
      }
  render() {
    return (
      <div>
        <input type='text' ref={this.inputRef} />
        <button onClick={this.clickHandler}>Click</button>
      </div>
    )
  }
}

export default RefsDemo

REFs WITH CLASS COMPONENTS
==========================
import React, { Component } from 'react'
import Input from './Input'

class FocusInput extends Component {
    constructor(props) {
      super(props)
      this.componentRef = React.createRef()
    }

    clickHandler = () =>{
        this.componentRef.current.focusInput()
    }
    
  render() {
    return (
      <div>
      <Input ref={this.componentRef}/>
        <button onClick={this.clickHandler}>Focus component</button>
      </div>
    )
  }
}

export default FocusInput

import React, { Component } from 'react'

export class Input extends Component {
    constructor(props) {
      super(props)
      this.inputRef = React.createRef()
    }
    focusInput(){
        this.inputRef.current.focus()
    }
  render() {
    return (
      <div>
        <input type='text' ref={this.inputRef} />
      </div>
    )
  }
}

export default Input

FORWARDING REFs
===============
import React, { Component } from 'react'
import FRInput from './FRInput'

class FRParentInput extends Component {
    constructor(props) {
      super(props)
      this.inputRef = React.createRef()
    }

    clickHandler = () =>{
        this.inputRef.current.focus()
    }
    
  render() {
    return (
      <div>
        <FRInput ref={this.inputRef} />
        <button onClick={clickHandler}>Focus Input</button>
      </div>
    )
  }
}

export default FRParentInput

import React from 'react'

//function FRInput() {
  //return (
    //<div>
      //<input type='text' />
    //</div>
  //)
//}

const FRInput = React.forwardRef((props, ref)=>{
    return(
        <div>
            <input type='text' ref={ref} />
        </div>
    )
})

export default FRInput

PORTALS
=======
import React from 'react'
import ReactDOM from 'react-dom'

function PortalsDemo() {
  return ReactDOM.createPortal(
    <h1>
    PortalsDemo
    </h1>,
    document.getElementById('portal-root')
  )
}

export default PortalsDemo

public/index.html
<body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    <div id="portal-root"></div>


ERROR BOUNDARY (or) ERROR HANDLING METHODS
==========================================
Error Boundary
	=> A class component that implements either one or both of the life cycle methods 
	getDerivedStateFromError or componentDidCatch becomes an error boundary.
	=> The static method getDerivedStateFromError method is used to render a fallback UI after the error is thrown and 
	the componentDidCatch method is used to log the error information.

import React from 'react'

function Hero({heroName}) {
    if(heroName === 'Joker'){
        throw new Error('Not a hero')
    }
  return (
    <div>
      {heroName}
    </div>
  )
}

export default Hero

import React, { Component } from 'react'

class ErrorBoundary extends Component {

    constructor(props) {
      super(props)
    
      this.state = {
         hasError: false
      }
    }
    

static getDerivedStateFromError(error){
   return{
    hasError: true
   } 
}

componentDidCatch(error, info){
    console.log(error)
    console.log(info)
}

  render() {  
    if(this.state.hasError){
        return <h1>Something went wrong</h1>
    }else{
        return this.props.children
    }
  }
}

export default ErrorBoundary

Summary
-------
=> Error boundaries are React components that catch Javascript error in their child component tree, log those errors and display a fall-back UI.
=> A class component becomes an Error Boundary by defining either or both of getDerivedStateFromError and componentDidCatch lifecycle methods.
=> The placement of the error boundary also matters as it controls if the entire app should have the fallback UI or just the component
	causing the problem.
=> Provide a way to gracefully handle error in application code.

HIGHER ORDER COMPONENTS
=======================

import React, { Component } from 'react'

class ClickCounter extends Component {

constructor(props) {
  super(props)

  this.state = {
     count: 0
  }
}

incrementHandler = ()=>{
    this.setState(prevState=>{
        return {count: prevState.count + 1}
    })
}

  render() {
      const {count} = this.state
        return <button onClick={this.incrementHandler}>Click {count} times</button>   
  }
}

export default ClickCounter


import React, { Component } from 'react'

class HoverCount extends Component {
    constructor(props) {
      super(props)
    
      this.state = {
         count: 0
      }
    }

    incrementHover=()=>{
        this.setState(prevState=>{
            return {count: prevState.count + 1}
        })
    }
    
  render() {
     const {count} = this.state
        return <h2 onMouseOver={this.incrementHover}>Hover count {count}</h2>
       
  }
}

export default HoverCount


Why Higher Order components?
=> To share common functionality between components

Higher Order Components - HOC
-----------------------------
=> A pattern where a function takes a component as an argument and returns a new component.
=> const newComponent = higherOrderComponent(originalComponent)
=> const enhanceComponent = higherOrderComponent(originalComponent)
=> Ex: const ironMan = withSuit(TonyStark)

code snippets

import React from "react";

const UpdatedComponent = (OriginalComponent, incrementCountValue) => {
    class NewComponent extends React.Component {
        constructor(props) {
            super(props)
          
            this.state = {
               count: 0
            }
          }
          
          incrementCount = ()=>{
              this.setState(prevState=>{
                  return {count: prevState.count + incrementCountValue}
              })
          }
        render(){
            return <OriginalComponent 
            count={this.state.count}
            incrementCount={this.incrementCount}
            {...this.props}
            />
        }
    }
    return NewComponent
}
export default UpdatedComponent

import React, { Component } from 'react'
import UpdatedComponent from './WithCounter'

class HoverCount extends Component {    
  render() {
     const {count, incrementCount} = this.props
        return <h2 onMouseOver={incrementCount}> Hover count {count}</h2>
       
  }
}

export default UpdatedComponent(HoverCount, 10)

import React, { Component } from 'react'
import UpdatedComponent from './WithCounter'

class ClickCounter extends Component {
  render() {
      const {count, incrementCount} = this.props
        return <button onClick={incrementCount}> {this.props.name}
       Click {count} times</button>   
  }
}

export default UpdatedComponent(ClickCounter, 5)

import './App.css';    
import ClickCounter from './components/ClickCounter';
import HoverCount from './components/HoverCount';
import './components/NormaCss.css'      

function App() {
  return (
    <div className="App">
    <ClickCounter name={'madhu'}/>
     <HoverCount/>  

      
    </div>
  );
}

export default App;

RENDER PROPS
============
=> The term 'render prop' refers to a technique for sharing code between React components using a prop whose value is a function.
import React, { Component } from 'react'

class User extends Component {
  render() {
    return (
      <div>
        {this.props.name(false)}
      </div>
    )
  }
}

export default User

import './App.css';      
import './components/NormaCss.css'      
import User from './components/User';

function App() {
  return (
    <div className="App">
      <User name={(isLoggedIn) => isLoggedIn?'madhu':'Guest'}/>
    </div>
  );
}

export default App;


code snippets
---------------
import './App.css';
import ClickCounterTwo from './components/ClickCounterTwo';
import Counter from './components/Counter';
import HoverCounter from './components/HoverCounter';
import './components/NormaCss.css'
import User from './components/User';

function App() {
  return (
    <div className="App">
      <Counter
      render={(count, incrementCount) => (
        <ClickCounterTwo count={count} incrementCount={incrementCount} />
      )} />
      <Counter render={(count, incrementCount) => (<HoverCounter count={count} incrementCount={incrementCount} />)} />
    </div>
  );
}

export default App;

import React, { Component } from 'react'

class Counter extends Component {

    constructor(props) {
      super(props)
    
      this.state = {
         count: 0
      }
    }
    
    incrementCount = () => {
       this.setState(prevState => {
        return {count: prevState.count + 1}
       })
    }

  render() {
    return (
      <div>
         {this.props.render(this.state.count, this.incrementCount)}
      </div>
    )
  }
}

export default Counter

import React, { Component } from 'react'

class HoverCounter extends Component {
  render() {
    const {count, incrementCount} = this.props
    return (
      <h1 onMouseOver={incrementCount}>
        Hover {count} times
      </h1>
    )
  }
}

export default HoverCounter

import React, { Component } from 'react'

class ClickCounterTwo extends Component {    
  render() {
    const {count, incrementCount} = this.props
    return <button onClick={incrementCount}>
        click {count} times
      </button>
    
  }
}

export default ClickCounterTwo

CONTEXT
=======
=> Context provides a way to pass data through the component tree without having to pass props down manually at every level.

1. Create the Context
2. Provide a Context value
3. Consume the Context value


import './App.css'; 
import ComponentC from './components/ComponentC';
import { UserProvider } from './components/UserContext';
import './components/NormaCss.css' 

function App() {
  return (
    <div className="App">
      {/**<UserProvider value={'madhu'}> */} 
          <ComponentC />
       {/**</UserProvider>*/} 
    </div>
  );
}

export default App;

import React, { Component } from 'react'
import { UserConsumer } from './UserContext'

class ComponentF extends Component {
  render() {
    return (
      
        <UserConsumer>
            {
                username => {
                    return <div>Hello {username}</div>
                }
            }
        </UserConsumer>
      
    )
  }
}

export default ComponentF


import React from "react";

//const UserContext = React.createContext()

//2nd type
const UserContext = React.createContext('madhu')

const UserProvider = UserContext.Provider
const UserConsumer = UserContext.Consumer

export {UserProvider, UserConsumer}

import React, { Component } from 'react'
import ComponentF from './ComponentF'

class ComponentE extends Component {
  render() {
    return  <ComponentF />
  }
}

export default ComponentE

import React, { Component } from 'react'
import ComponentE from './ComponentE'

class ComponentC extends Component {
  render() {
    return <ComponentE/>
  }
}

export default ComponentC

REACT & HTTP
==============
=> Install axios >npm install axios

HTTP GET Request
----------------
import React, { Component } from 'react'
import axios from 'axios'

class PostList extends Component {
constructor(props) {
  super(props)
  this.state = {
     posts: [],
     errorMsg: ''
  }
}
componentDidMount(){
    axios.get('https://jsonplaceholder.typicode.com/posts')
    .then(response=>{
        console.log(response)
        this.setState({posts: response.data})
    })
    .catch(error=>{
        console.log(error)
        this.setState({errorMsg: 'Error receiving data'})
    })
}
  render() {
    const {posts, errorMsg} = this.state
    return (
      <div>
        PostList
        {
            posts.length ? 
            posts.map(post => <div key={post.id}>{post.title}</div>) : 
            null
        }
        {
            errorMsg ? <div>{errorMsg}</div> : null 
        }
    </div>
    )
  }
}
export default PostList

HTTP POST Request
------------------
import React, { Component } from 'react'
import axios from 'axios'

class PostForm extends Component {

constructor(props) {
  super(props)

  this.state = {
     userId: '',
     title: '',
     body: ''
  }
}
changeHandler = (e) => {
    this.setState({ [e.target.name] : e.target.value})
}
submitHandler = e => {
    e.preventDefault();
    console.log(this.state)

    axios.get('https://jsonplaceholder.typicode.com/posts')
    .then(response => {
        console.log(response)
    })
    .catch(error=>{
        console.log(error)
    })
}


  render() {
    const {userId, title, body} = this.state
    return (
      <div>

        PostForm
        <form onSubmit={this.submitHandler}>
            <div><input type='text' name='userId' value={userId} onChange={this.changeHandler} /></div>
            <div><input type='text' name='title' value={title} onChange={this.changeHandler} /></div>
            <div><input type='text' name='body' value={body} onChange={this.changeHandler} /></div>
            <button type='submit'>Submit</button>
        </form>
        
        </div>
    )
  }
}

export default PostForm

HOOKS
=====
What are Hooks?
=> Hooks are a new feature addition in React version 16.8 which allow you to use React features without having to write a class.
	Ex: State of a component
=> Hooks don't work inside classes

Why Hooks?
=> Understand how this keyword works in javascript
=> Remember to bind event handlers in class components
=> Class don't minify very well and make hot reloading very unreliable
=> There is no particular way to resuse stateful component logic
=> HOC and render props patterns do address this problem
=> Makes the code harder to follow
=> There is need a to share stateful login in a better way
=> Create components for complex scenarios such as data fetching and subscribing to events 
=> Related code is not organized in one place
=> Ex: Data fetching - In componentDidMount and componentDidUpdate
=> Ex: Event listeners - In componentDidMount and componentWillUnmount
=> Because of stateful logic - Cannot break components into smaller ones

Noteworthy Points
-----------------
=> React version 16.8 or higher
=> Completely opt in
=> Hooks don't contain any breaking changes and the release is 100% backwards-compatible
=> Classes won't be removed from React
=> Can't use Hooks inside of a class component
=> Hooks don't replace your existing knowledge of React concepts
=> Instead, Hooks provide a more direct API to the React concepts you already know

useState Hook
=============
Rules of Hooks
--------------
=> "Only Call Hooks at the Top Level" Don't call Hooks inside loops, conditions or nested functions
=> "Only Call Hooks from React Functions" Call them from within React functional components and not just any regular JavaScript function

import React, { useState } from 'react'

function HookCounter() {

const [count, setState] = useState(0)

  return (
    <div>HookCounter
        <button onClick={()=>setState(count+1)}>Count{count}</button>
    </div>
  )
}

export default HookCounter

useState with previous state
============================
import React, { useState } from 'react'

function HookCounterTwo() {

const initialCount = 0
const [count, setCount] = useState(initialCount)

const incrementFive = () => {
    for(let i=0; i<5; i++){
        //setCount(count+1)
        setCount(prevState => prevState + 1)
    }
}

  return (
    <div>
        HookCounterTwo

        Count: {count}<br></br>

        <button onClick={()=>{setCount(count - 1)}}>Decrement</button>
        <button onClick={()=>{setCount(initialCount)}}>Reset</button>
        <button onClick={()=>{setCount(count + 1)}}>Increment</button>
        <button onClick={incrementFive}>Increment 5</button>
    </div>
  )
}

export default HookCounterTwo

useState with object
====================
import React, { useState } from 'react'

function HookCounterThree() {
    const [name, setName] = useState({firstName: '', lastName:''})
  return (
    <div>
        HookCounterThree
        <form>
            <input type='text' 
            value={name.firstName}
            onChange={e => setName({...name,firstName: e.target.value})}
            />
            <input
            type='text'
            value={name.lastName}
            onChange={e => setName({...name,lastName: e.target.value})}
            />
            First Name: {name.firstName}<br></br>
            Last Name: {name.lastName}
        </form>
        </div>
  )
}

export default HookCounterThree

useState with Array
===================
import React, { useState } from 'react'

function HookConterFour() {
    const [items, setItems] = useState([])
    const addItem = () => {
        setItems([...items,{
            id: items.length,
            value: Math.floor(Math.random() * 10) + 1
        }])
    }
  return (
    <div>
        HookConterFour
        <button onClick={addItem}></button>
<ul>
    {
        items.map(item=>(<li key={item.id}>{item.value}</li>))
    }
</ul>
        </div>
  )
}

export default HookConterFour

Summary - useState
------------------
=> The useState hook lets you add state to functional components
=> In classes, the state is always an object
=> With the useState hook, the state doesn't have to be an object
=> The useState hook returns an array with 2 elements
=> The first element is the current value of the state, and the second element is a state setter function
=> New state value depends on the previous state value? You can pass a function to the setter function
=> When dealing with objects or arrays, always make sure to spread your state variable and then call the setter function


useEffect
=========
=> The Effect Hooks lets you perform side effects in functional components
=> It is a close replacement for componentDidMount, componentDidUpdate and componentWillUnmount

import React, { useState, useEffect} from 'react'

function HookCounterFive() {
    const [count, setCount] = useState(0)
    useEffect(() => {
        document.title = `You clicked ${count} times`
    })
  return (
    <div>
         
        <button onClick={()=>setCount(count + 1)}>clicked {count} times</button>
    </div>
  )
}

export default HookCounterFive

Conditionally run effects
=========================
import React, { useEffect, useState } from 'react'

function HookCounterOne() {
    const [count, setCount] = useState(0)
    const [name, setName] = useState('')

    useEffect(()=>{
        console.log('updating title element')
        document.title = `You clicked ${count} times`
    },[count])
  return (
    <div>
    <input type='text' value={name} onChange={e=> setName(e.target.value)}/>
      <button onClick={()=>setCount(count + 1)}>Count {count}</button>
    </div>
  )
}

export default HookCounterOne

Run effects only once
---------------------
import React, { useEffect, useState } from 'react'

function HookCountTwo() {
    const [x, setX] = useState('')
    const [y, setY] = useState('')

    useEffect(()=>{
        console.log('useEffect')
        window.addEventListener('mousemove', logMousePosition)
    },[])
    const logMousePosition = e => {
        setX(e.clientX)
        setY(e.clientY)
    }

  return (
    <div>
    X - {x}, Y - {y}  
    </div>
  )
}

export default HookCountTwo

useEffect with cleanup
----------------------
useEffect with incorrect dependency
------------------------------------
with class components
---------------------
import React, { Component } from 'react'

class IntervalClassCounter extends Component {

constructor(props) {
  super(props)

  this.state = {
     count: 0
  }
}
componentDidMount(){
    this.interval = setInterval(this.tick, 1000)
}
componentWillUnmount(){
    clearInterval(this.interval)
}
tick = () => {
    this.setState({
        count: this.state.count + 1
    })
}


  render() {
    return (
      <div>
        <h1>{this.state.count}</h1>
      </div>
    )
  }
}

export default IntervalClassCounter

with useEffect and hooks
------------------------
import React, { useEffect, useState } from 'react'

function IntervalHookCounter() {
    const [count, setCount] = useState(0)
    
    const tick = () => {
        setCount(count + 1)
    }
    useEffect(()=>{
        const interval = setInterval(tick, 1000)
        return ()=>{
            clearInterval(interval)
        }
    },[count])
  return (
    <div>
      {count}
    </div>
  )
}

export default IntervalHookCounter 

another way

import React, { useEffect, useState } from 'react'

function IntervalHookCounter() {
    const [count, setCount] = useState(0)
    
    const tick = () => {
        setCount(prevCount => prevCount + 1)
    }
    useEffect(()=>{
        const interval = setInterval(tick, 1000)
        return ()=>{
            clearInterval(interval)
        }
    },[])
  return (
    <div>
      {count}
    </div>
  )
}

export default IntervalHookCounter 

Fetching data with useEffect Part1
===================================
import React, { useEffect, useState } from 'react'
import axios from 'axios'

function DataFetchinguseEffect() {
    const [data, setData] = useState([])

    useEffect(()=>{
        axios.get('https://jsonplaceholder.typicode.com/posts')
        .then(response =>{
          setData(response.data)
        }).catch(error=>{
          console.log(error)
        })
    },[])
  return (
    <div>
    <ul>
      {
        data.map(post=> <li key={post.id}>{post.title}</li>)
      }
      </ul>
    </div>
  )
}

export default DataFetchinguseEffect


Fetching data with useEffect Part2
===================================
import React, { useEffect, useState } from 'react'
import axios from 'axios'

function DataFetchinguseEffect() {
    const [post, setPost] = useState({})
    const [id, setId] = useState(1)

    useEffect(()=>{
        axios.get(`https://jsonplaceholder.typicode.com/posts/${id}`)
        .then(response =>{
          setPost(response.data)
        }).catch(error=>{
          console.log(error)
        })
    },[id])
  return (
    <div>
    <input type='text' value={id} onChange={e=> setId(e.target.value)} /><br></br>
     {post.title}
    </div>
  )
}

export default DataFetchinguseEffect

Fetching data with useEffect Part3
===================================
import React, { useEffect, useState } from 'react'
import axios from 'axios'

function DataFetchinguseEffect() {
    const [post, setPost] = useState({})
    const [id, setId] = useState(1)
    const [idFromButton, setIdFromButton] = useState(1)

    const handleClick = () =>{
      setIdFromButton(id)
    }

    useEffect(()=>{
        axios.get(`https://jsonplaceholder.typicode.com/posts/${idFromButton}`)
        .then(response =>{
          setPost(response.data)
        }).catch(error=>{
          console.log(error)
        })
    },[idFromButton])
  return (
    <div>
    <input type='text' value={id} onChange={e=> setId(e.target.value)} /><br></br>
    <button onClick={handleClick}>Get Post</button>
     <div>{post.title}</div>
    </div>
  )
}

export default DataFetchinguseEffect

useContext Hook Part 1
======================
=> Context provides a way to pass data through the component tree without having to pass props down manually at every level.

import './App.css'; 
import ComponentC from './components/ComponentC';
import React from 'react';
 
export const UserContext = React.createContext()
export const ChannelContext = React.createContext()

function App() {
  return (
    <div className="App">

      <UserContext.Provider value={'madhu'}>
        <ChannelContext.Provider value={'codevolution'}>
          <ComponentC />
        </ChannelContext.Provider>
      </UserContext.Provider>
       
      
    </div>
  );
}

export default App;

import React from 'react'
import { ChannelContext, UserContext } from '../App'

function ComponentF() {
  return (
    <div>ComponentF
        <UserContext.Consumer>
        {
            user=>{
                return(
                    <ChannelContext.Consumer>
                        {
                        channel=>{
                            return <div>User is : {user}, channel: {channel}</div>
                        }
                    }
                    </ChannelContext.Consumer>
                )


                
            }
        }
        </UserContext.Consumer>
        
    </div>
  )
}

export default ComponentF

import React from 'react'
import ComponentF from './ComponentF'

function ComponentE() {
  return (
    <div>
        ComponentE
        <ComponentF />
    </div>
  )
}

export default ComponentE

import React from 'react'
import ComponentE from './ComponentE'

function ComponentC() {
  return (
    <div>
        ComponentC
        <ComponentE />
    </div>
  )
}

export default ComponentC

useContext Hook Part3
=====================
another and prefered way to consume context values
import React from 'react'
import ComponentF from './ComponentF'
import { useContext } from 'react'
import { ChannelContext, UserContext } from '../App'

function ComponentE() {

const user = useContext(UserContext)
const channel = useContext(ChannelContext)

  return (
    <div>
        ComponentE<br></br>
        {user} - {channel}
        <ComponentF />
    </div>
  )
}

export default ComponentE

useReducer Hook
===============
=> useReducer is a hook that is used of state management
=> It's an alteranative to useState
=> useState is built using useReducer

reduce vs useReducer
====================
reduce in Javascript
array.reduce(reducer, initialValue)
sigleValue = reducer(accumulator, itemValue)
reduce method returns a single value

useReducer in React
useReducer(reducer,initialState)
newState=reducer(currentState, action)
useReducer returns a pair of values. [newState, dispatch]

useReducer (Simple state & action)
==================================
import React, { useReducer, useState } from 'react'

const initialState = 0
const reducer = (state, action) => {
    switch(action){
        case 'increment' : return state + 1
        case 'decrement' : return state - 1
        case 'reset' : return initialState
        default : return state
    }
}

function CounterOne() {

const [count, dispatch] = useReducer(reducer, initialState)

  return (
    <div>
        CounterOne<br></br>
        <div>
            <div>{count}</div>
            <button onClick={()=>dispatch('decrement')}>Decrement</button>
            <button onClick={()=>dispatch('reset')}>Reset</button>
            <button onClick={()=>dispatch('increment')}>Increment</button>        </div>
    </div>
  )
}

export default CounterOne

import React, { useReducer } from 'react'

const initialState = {
    firstCounter: 0
}
const reducer = (state, action) => {
    switch(action.type){
        case 'increment' : return {firstCounter: state.firstCounter + action.value}
        case 'decrement' : return {firstCounter: state.firstCounter - action.value}
        case 'reset' : return initialState
        default : return state
    }
}

function CounterTwo() {

const [count, dispatch] = useReducer(reducer, initialState)

  return (
    <div>
        CounterOne<br></br>
        <div>
            <div>count - {count.firstCounter}</div>
            <button onClick={()=>dispatch({type: 'decrement', value: 1})}>Decrement</button>
            <button onClick={()=>dispatch({type: 'decrement', value: 5})}>Decrement 5</button>
            <button onClick={()=>dispatch({type:'reset'})}>Reset</button>
            <button onClick={()=>dispatch({type:'increment', value: 1})}>Increment</button> 
            <button onClick={()=>dispatch({type:'increment', value: 5})}>Increment 5</button>
                   </div>
    </div>
  )
}

export default CounterTwo

import React, { useReducer } from 'react'

const initialState = {
    firstCounter: 0, secondCounter: 10
}
const reducer = (state, action) => {
    switch(action.type){
        case 'increment' : return {...state, firstCounter: state.firstCounter + action.value}
        case 'decrement' : return {...state, firstCounter: state.firstCounter - action.value}
        case 'increment2' : return {...state, secondCounter: state.secondCounter + action.value}
        case 'decrement2' : return {...state, secondCounter: state.secondCounter - action.value}
        case 'reset' : return initialState
        default : return state
    }
}

function CounterTwo() {

const [count, dispatch] = useReducer(reducer, initialState)

  return (
    <div>
        CounterOne<br></br>
        <div>
            <div>count - {count.firstCounter}</div>
            <div>count2 - {count.secondCounter}</div>
            <button onClick={()=>dispatch({type: 'decrement', value: 1})}>Decrement</button>
            <button onClick={()=>dispatch({type: 'decrement2', value: 1})}>Decrement 5</button>
            <button onClick={()=>dispatch({type:'reset'})}>Reset</button>
            <button onClick={()=>dispatch({type:'increment2', value: 1})}>Increment</button> 
            <button onClick={()=>dispatch({type:'increment', value: 1})}>Increment 5</button>
                   </div>
    </div>
  )
}

export default CounterTwo

Multiple useReducers
====================
import React, { useReducer, useState } from 'react'

const initialState = 0
const reducer = (state, action) => {
    switch(action){
        case 'increment' : return state + 1
        case 'decrement' : return state - 1
        case 'reset' : return initialState
        default : return state
    }
}

function CountThree() {

const [count, dispatch] = useReducer(reducer, initialState)
const[countTwo, dispatchTwo] = useReducer(reducer, initialState)

  return (
    <div>
        
        <div>
            <div>count - {count}</div>
            <button onClick={()=>dispatch('decrement')}>Decrement</button>
            <button onClick={()=>dispatch('reset')}>Reset</button>
            <button onClick={()=>dispatch('increment')}>Increment</button>        
        </div>
        <div>
            <div>count two - {countTwo}</div>
            <button onClick={()=>dispatchTwo('decrement')}>Decrement</button>
            <button onClick={()=>dispatchTwo('reset')}>Reset</button>
            <button onClick={()=>dispatchTwo('increment')}>Increment</button>        
        </div>
    </div>
  )
}

export default CountThree

useReducer with useContext
===========================
useReducer - Local State Management
Share state between component - Global state management
useReducer + useContext

import './App.css';   
import React, { useReducer } from 'react';
import ComponentA from './components/ComponentA';
import ComponentB from './components/ComponentB';
  
const initialState = 0
const reducer = (state, action) => {
    switch(action){
        case 'increment' : return state + 1
        case 'decrement' : return state - 1
        case 'reset' : return initialState
        default : return state
    }
}

export const CountContext = React.createContext()

function App() {
  const [count, dispatch] = useReducer(reducer, initialState)
  return (
    <CountContext.Provider value={{countState: count, countDispatch: dispatch}}>
    <div className="App">
      <div>Count - {count}</div>
      <ComponentA />
      <ComponentB />
    </div>
    </CountContext.Provider>
  );
}

export default App;

import React, { useContext } from 'react'
import { CountContext } from '../App'

function ComponentA() {

const countContext = useContext(CountContext)

  return (
    <div>ComponentA - {countContext.countState}

            <button onClick={()=>countContext.countDispatch('decrement')}>Decrement</button>
            <button onClick={()=>countContext.countDispatch('reset')}>Reset</button>
            <button onClick={()=>countContext.countDispatch('increment')}>Increment</button> 
    </div>
  )
}

export default ComponentA

import React, { useContext } from 'react'
import { CountContext } from '../App'

function ComponentB() {

const countContext = useContext(CountContext)

  return (
    <div>ComponentB - {countContext.countState}

            <button onClick={()=>countContext.countDispatch('decrement')}>Decrement</button>
            <button onClick={()=>countContext.countDispatch('reset')}>Reset</button>
            <button onClick={()=>countContext.countDispatch('increment')}>Increment</button> 
    </div>
  )
}

export default ComponentB

Fetching data with useReducer Part 1
====================================
import axios from 'axios'
import React, { useEffect, useState } from 'react'

function DataFetchingOne() {

const [loading, setLoading] = useState(true)
const [error, setError] = useState('')
const [post, setPost] = useState({})

useEffect(()=>{
    axios.get('https://jsonplaceholder.typicode.com/posts/1')
    .then(response=>{
        setLoading(false)
        setError('')
        setPost(response.data)
    })
    .catch(error=>{
        setLoading(false)
        setError('something went wrong')
        setPost({})
    })
},[])

  return (
    <div>
        DataFetchingOne <br></br>
        { loading ? 'Loading' : post.title }
        { error ? error : null }
    </div>
  )
}

export default DataFetchingOne

Fetching data with useReducer Part 2
====================================
import React, { useReducer, useEffect } from 'react'
import axios from 'axios'

const initialState = {
    loading: true,
    error: '',
    post: {}
}

const reducer = (state, action) => {
    switch(action.type){
        case 'FETCH_SUCCESS':
            return{
                loading: false,
                post: action.payload,
                error: ''
            }
        case 'FETCH_ERROR':
            return{
                loading: false,
                post: {},
                error: 'something went wrong'
            }
        default:
            return state
    }
}

function DataFetchingTwo() {
    const [state, dispatch] = useReducer(reducer, initialState)

    useEffect(()=>{
        axios.get('https://jsonplaceholder.typicode.com/posts/1')
        .then(response=>{
             dispatch({type: 'FETCH_SUCCESS', payload: response.data})
        })
        .catch(error=>{
            dispatch({type: 'FETCH_ERROR'}) 
        })
    },[])

  return (
    <div>DataFetchingTwo

{ state.loading ? 'Loading' : state.post.title }
        { state.error ? state.error : null }
    </div>
  )
}

export default DataFetchingTwo

useState vs useReducer
======================
Scenario				useState			useReducer
-----------------------------------------------------------------------------------------------------------------------------------
Type of state				Number,String,Boolean		Object or Array
Number of state transitions		One or Two			Too many
Related state transitions		No				Yes
Business logic				No business logic		Complex business logic
Local vs global				Local				Global

useCallback Hook
================
=> useCallback is a hook that will return a memorized version of the callback function that only changes if one of the dependencies has changed.
=> It is useful when passing callbacks to optimized child components that rely on reference equality to prevent unnecessary renders.

import React, { useCallback, useState } from 'react'
import Count from './Count'
import Button from './Button'
import Title from './Title'

function ParentComponent() {
    console.log('ParentComponent')

const [age, setAge] = useState(25)
const [salary, setSalary] = useState(250000)

const incrementAge = useCallback(() => {
    setAge(age + 1)
}) 
const incrementSalary = useCallback(() => {
    setSalary(salary + 1000)
}) 
  return (
    <div>
        ParentComponent<br></br>
        <Title />
        <Count text='Age' count={age} />
        <Button handleClick={incrementAge}>Increment Age</Button>
        <Count text='Salary' count={salary} />
        <Button handleClick={incrementSalary}>Increment Salary</Button>
        
        </div>
  )
}

export default ParentComponent

import React from 'react'

function Button({handleClick, children}) {
    console.log('button')
  return (
    <div>
        Button<br></br>

        <button onClick={handleClick}>{children}</button>
        
        </div>
  )
}

export default React.memo(Button)

import React from 'react'

function Count({text, count}) {
    console.log(`count ${text}`)
  return (
    <div>
        Count<br></br>
        {text} - {count}
        
        </div>
  )
}

export default React.memo(Count)

import React from 'react'

function Title() {
    console.log('Rendering Title')
  return (
    <div>useCallback Hook</div>
  )
}

export default React.memo(Title)

useMemo Hook
============
import React, {useState} from 'react'


function Count() {

   const [counterOne, setCounterOne] = useState(0)
   const [counterTwo, setCounterTwo] = useState(0)

   const incremntOne = () => {
    setCounterOne(counterOne + 1)
   }
   const incremntTwo = () => {
    setCounterTwo(counterTwo + 1)
   }
   const isEven = () => {
    return counterOne % 2 == 0
   }
     
  return (
    <div>
        
        <div>
          <button onClick={incremntOne}>Counter one - {counterOne}</button> 
          <span>{isEven() ? 'Even' : 'Odd'}</span>
        </div>
        <div>
          <button onClick={incremntTwo}>Counter one - {counterTwo}</button>
        </div>
        
        </div>
  )
}

export default React.memo(Count)





















